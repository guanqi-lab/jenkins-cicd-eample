# .buildkite/pipeline.yml

# 定义环境变量，方便在多个步骤中复用
env:
  IMAGE_REPO: "ghcr.io/${BUILDKITE_ORGANIZATION_SLUG}/${BUILDKITE_PIPELINE_SLUG}"
  CONTAINER_NAME: "buildkite-hello-world-go-service"

steps:
  # 【移除】不再需要独立的登录步骤和 depends_on
  # - label: "🔑 Login to GHCR"
  #   ...

  # --- 自动化 CI 步骤 ---
  - label: "📦 Build and Push Image"
    if: build.pull_request.id == null
    plugins:
      # 【回归并修正】将登录逻辑放回插件内部
      - docker#v5.10.0:
          image: "${IMAGE_REPO}"
          # Docker 插件会在执行所有操作前，使用这里的凭证进行登录
          login:
            username: "${BUILDKITE_ORGANIZATION_SLUG}"
            password-env: BUILDKITE_GHCR_TOKEN
          # 构建与推送的配置
          tag: "${BUILDKITE_DATE_YYYYMMDD}.${BUILDKITE_BRANCH}.${BUILDKITE_COMMIT::8}"
          push: true
    # 将生成的镜像标签存为元数据，供后续步骤使用
    artifact_paths:
      - "buildkite-meta-data/docker-image-tag"

  # --- 手动批准 CD 步骤 ---
  - block: "🚀 Deploy to Production"
    prompt: "请确认是否将以下镜像部署到生产环境？"
    fields:
      - text: "Image Tag"
        key: "image-tag-to-deploy"
        default: "$(buildkite-agent artifact download 'buildkite-meta-data/docker-image-tag' --stdout)"

  # --- 自动化 CD 步骤 ---
  - label: "🚀 Executing Deployment"
    command: |
      set -euo pipefail
      IMAGE_TAG=$(buildkite-agent artifact download 'buildkite-meta-data/docker-image-tag' --stdout)
      
      echo "--- 部署信息 ---"
      echo "镜像仓库: ${IMAGE_REPO}"
      echo "镜像标签: ${IMAGE_TAG}"

      echo "--- 登录到 GHCR ---"
      buildkite-agent secret get BUILDKITE_GHCR_TOKEN | docker login ghcr.io -u "${BUILDKITE_ORGANIZATION_SLUG}" --password-stdin

      echo "--- 拉取新镜像 ---"
      docker pull "${IMAGE_REPO}:${IMAGE_TAG}"

      echo "--- 停止并移除旧容器 ---"
      docker stop "${CONTAINER_NAME}" || true
      docker rm "${CONTAINER_NAME}" || true

      echo "--- 启动新容器 ---"
      docker run -d \
        -p 8080:8080 \
        --name "${CONTAINER_NAME}" \
        --restart always \
        "${IMAGE_REPO}:${IMAGE_TAG}"
      
      echo "✅ 部署成功！"